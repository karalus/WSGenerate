import javax::xml::namespace;
import javax::wsdl;

import com::artofarc::wsimport;
import com::artofarc::schema;

extension oaw::extensions::schema2 reexport;
extension oaw::extensions::wsdl;

private Boolean _generateClient() : GLOBALVAR generateClient;
boolean generateClient() : _generateClient() == true;
private Boolean _generateServer() : GLOBALVAR generateServer;
boolean generateServer() : _generateServer() == true;
String getDBSchema() : GLOBALVAR dbSchema;
boolean isGenerateSmallXML(SchemaDef this) : false;

String lineSeparator() : "\r\n";

//String repeat(String x, int n) : JAVA org.apache.commons.lang.StringUtils.repeat( java.lang.String, int);
String repeat(String x, int n) : n > 0 ? x + repeat(x, n-1) : "";
String chomp(String s, String suffix) : s.endsWith(suffix) ? s.subString(0, s.length - suffix.length) : s;
String chomp(String s, int n) : s.subString(0, s.length - n);
String padStringLeft(String s, char padChar, int len) : s.length < len ? padStringLeft(padChar + s, padChar, len) : s;

private String convertUri(String ns, String separator, boolean firstUpper) :
	JAVA com.artofarc.util.UriHelper.convertUri(java.lang.String, java.lang.String, java.lang.Boolean);
private java::net::URI createURI(String uri) :
	JAVA com.artofarc.util.UriHelper.createURI(java.lang.String);
private String getQueryParam(String uri, String key) : createURI(uri).query.split("&").selectFirst(p|p.startsWith(key + "=")).split("=").get(1);

String XSD2PackageName(SchemaDef this) : model.bindingDefinition.getMappingForNamespace(targetNamespace);
	
String XSDType2Oracle(SchemaDef ns, String name, SchemaObject this) : checkLen(_XSDType2Oracle(ns, name, false), ns.targetNamespace, name);
String XSDType2Oracle(SchemaDef ns, String name, SchemaObject this, boolean isArray) : checkLen(_XSDType2Oracle(ns, name, isArray), ns.targetNamespace, name);
String XSDType2Oracle(SchemaDef ns, String name, SchemaObject this, String suffix) : checkLen(_XSDType2Oracle(ns, name, false) + suffix, ns.targetNamespace, name);

private String checkLen(String s, String uri, String name) : s.length > 30 ? "!!!Too long: " + name + " in " + uri + " mapped to " + s : s;
private cached String _XSDType2Oracle(SchemaObject this, SchemaDef ns, String name, boolean isArray) :
	let s = ns.getMappingForName(name, this) :
		s.endsWith("PayloadType") ? s.chomp(11) + (isArray ? "P_CT" : "P_T") :
			(s.endsWith("Type") ? s.chomp(4) : s) + (isArray ? "_CT" : "_T");

String enumValue2OracleName(SchemaDef owner, String oracleTypeName, Enum this) :
	let n = oracleTypeName.chomp(1) + value.replaceAll("\\.|,", "").replaceAll(" |-", "_") : // reduce "_T" to "_"
		checkLen(owner.getMappingForName(n, this) + "_c", owner.targetNamespace, n);

//String anonymousTypeName(Primitive element, String parentTypeName) : let s = parentTypeName.chomp("Type") : (s.length > 0 ? s + element.name.toFirstUpper() : element.name) + "Type";

// Type mapping
String formatDocumentation(String doc, String prefix) : doc.split("\n").collect(e|e.trim()).reject(e|e.length == 0).collect(e|prefix + e + lineSeparator()).concat();
String concat(List[String] list) : list.isEmpty ? "" : (list.size > 1 ? list.first() + concat(list.withoutFirst()) : list.first());

String convertXSDBasicTypeOracle(QName this, Primitive primitive) : 
	isStringType() ? (isFixedLength(primitive) ? "CHAR(" + getMaxCharLength(primitive) + ")" : "VARCHAR2(" + getMaxCharLength(primitive) + " CHAR)") :
		(localPart == "int" && getIntegerTypeTotalDigits(primitive) == 10 ? "BINARY_INTEGER" : // more precise than NUMBER(10)
			(isInt32Type() || isIntegerType() ? (let td = getIntegerTypeTotalDigits(primitive) : td != null ? "NUMBER(" + td + ")" : "NUMBER") :
				(localPart == "decimal" ? (hasNumberFormat(primitive) ? "NUMBER(" + getNumberFormat(primitive) + ")" : "NUMBER") :
					(localPart == "dateTime" || localPart == "time" ? (hasTimezone(primitive) ? "TIMESTAMP WITH TIME ZONE" : "TIMESTAMP") :
						(localPart == "date" || localPart == "gYearMonth" ? (hasTimezone(primitive) ? "TIMESTAMP WITH TIME ZONE" : "DATE") :
							(localPart == "gYear" ? (hasTimezone(primitive) ? "TIMESTAMP WITH TIME ZONE" : "NUMBER(4)") :
								(localPart == "boolean" ? "BOOLEAN" :
									(localPart == "float" ? "BINARY_FLOAT" :
										(localPart == "double" ? "BINARY_DOUBLE" :
											(localPart == "base64Binary" ? "BLOB" :
												(localPart == "duration" ? "INTERVAL DAY TO SECOND" :
													(localPart == "anyType" ? "XMLTYPE" :
														"Illegal XSD type: " + localPart))))))))))));

//
private boolean hasNumberFormat(Primitive primitive) : primitive != null && (primitive.totalDigits != null || primitive.fractionDigits != null);
private String getNumberFormat(Primitive this) :
	totalDigits != null ? totalDigits.toString() + (fractionDigits != null ? "," + fractionDigits : "") :
		(fractionDigits != null ? numberDefaultPrecision().toString() + "," + fractionDigits : numberDefaultPrecision());
private int numberDefaultPrecision() : 38;
