«IMPORT com::artofarc::wsimport»

«EXTENSION oaw::extensions::db»
«EXTENSION oaw::extensions::wsdl»

«DEFINE Root FOR Model»

«IF mtomSupport()» 
«FILE "plsql/" + getDBSchema("/") + "Base64EncodeUtil.java"-»
create or replace and compile java source named «getDBSchema(".")»Base64EncodeUtil as
import java.util.Base64;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.SQLException;
import oracle.jdbc.OracleDriver;

/**
 * This class provides methods to encode/decode from base64 to binary.
 */
public class Base64EncodeUtil {

  public static Clob encode(final Blob input, final int lineSize, final String lineSep) throws SQLException {
    // Get default connection
    final Clob result = new OracleDriver().defaultConnection().createClob();
    result.setString(1, Base64.getMimeEncoder(lineSize, lineSep.getBytes()).encodeToString(input.getBytes(1, (int) input.length())));
    return result;
  }

  public static Blob decode(final Clob input) throws SQLException {
    // Get default connection
    final Blob result = new OracleDriver().defaultConnection().createBlob();
    result.setBytes(1, Base64.getMimeDecoder().decode(input.getSubString(1, (int) input.length())));
    return result;
  }

}
/
«ENDFILE»

«FILE "plsql/" + getDBSchema("/") + "ATTACHMENT_T.TYP"-»
CREATE OR REPLACE TYPE «getDBSchema(".")»ATTACHMENT_T AS OBJECT (
  content 	    BLOB,
  contentId     VARCHAR2(256),
  contentType   VARCHAR2(256),
  fileName      VARCHAR2(256)
)
/

«FOREACH bindingDefinition.getGlobalPropertyAsList("dbInternalUser") AS dbInternalUser-»
GRANT EXECUTE ON «getDBSchema(".")»ATTACHMENT_T TO «dbInternalUser»
/
«ENDFOREACH-»
«ENDFILE»

«FILE "plsql/" + getDBSchema("/") +"ATTACHMENT_CT.TYP"-»
CREATE OR REPLACE TYPE «getDBSchema(".")»ATTACHMENT_CT AS TABLE OF «getDBSchema(".")»ATTACHMENT_T
/

«FOREACH bindingDefinition.getGlobalPropertyAsList("dbInternalUser") AS dbInternalUser-»
GRANT EXECUTE ON «getDBSchema(".")»ATTACHMENT_CT TO «dbInternalUser»
/
«ENDFOREACH-»
«ENDFILE»

«FILE "plsql/" + getDBSchema("/") +"SOAP_MESSAGE_T.TYP"-»
CREATE OR REPLACE TYPE «getDBSchema(".")»SOAP_MESSAGE_T AS OBJECT (
  attachments ATTACHMENT_CT
)
/

«FOREACH bindingDefinition.getGlobalPropertyAsList("dbInternalUser") AS dbInternalUser-»
GRANT EXECUTE ON «getDBSchema(".")»SOAP_MESSAGE_T TO «dbInternalUser»
/
«ENDFOREACH-»
«ENDFILE»

«FILE "plsql/" + getDBSchema("/") + AttachmentContextPackageName() + ".PKS"-»
CREATE OR REPLACE PACKAGE «getDBSchema(".")»«AttachmentContextPackageName()»
/**
* <pre>
*
*  <br/>
*  Softwarekomponente:  api           -   Querschnittsfunktionalitäten für die API (Application Programming Interface)
*  <br/>
*
*  <b>Beschreibung:</b>
*  Dieses Package enthält Funktionalität, um Attachments zu verwalten, die als Binärdaten innerhalb von Soap-Requests übertragen werden.
*  !!! A C H T U N G  -- Modul ist generiert -- bitte nicht ändern !!!!
*
*  </pre>
*  @headcom
*  @CHECK  XXXX-XXXX  -- Checkprogramm für diese Komponente ausschalten
*
*  Änderungs-Historie:   (neue Einträge immer oben anfügen)
*  ========================================================
*  Revision  Wann      Wer              Was (Request und ASB / Störfall vermerken)
*  --------  --------  ---------------  ----------------------------------------
*  R1.0      27.09.19  M. Kiel          Neuerstellung des Packages
*/
IS

  ------------------------------------------------------------------------------
  -- öffentliche globale Variablen
  ------------------------------------------------------------------------------
  
  -- Package-Variable, in der die Attachments gespeichert werden
  g_attachment_obj soap_message_t;

  ------------------------------------------------------------------------------
  -- Prozeduren/Funktionen
  ------------------------------------------------------------------------------
  
  /**
  * Fügt der intern gespeicherten Liste ein Attachachment hinzu.
  *
  * @param   p_attachment_in             IN  Daten des Attachment als BLOB
  * @param   p_mime_type_in              IN  Mime-Type des Attachment (z.B. application/pdf)
  * @param   p_attachment_id_io          IN/OUT ID unter der das Attachments gepeichert wird
  * @param   p_filename_in               IN  Dateiname zum Attachment
  */
  PROCEDURE add_attachment (p_attachment_in IN BLOB
                           ,p_mime_type_in IN VARCHAR2
                           ,p_filename_in IN VARCHAR
                           ,p_attachment_id_io IN OUT NOCOPY VARCHAR2);
  
  /**
  * Gibt das Attachment zurück, das intern unter der angegebenen ID gespeicert ist.
  *
  * @param   f_attachment_id_in          IN  ID des Attachments
  *
  * @return  Daten zum Attachments als BLOB
  */
  FUNCTION get_attachment (f_attachment_id_in IN VARCHAR2)
    RETURN BLOB;
    
  /**
  * Löscht die intern gespeicherten Attachments.
  *
  */
  PROCEDURE reset_attachments;
  
  /**
  * Setzt das interen Flag, das steuert, ob MTOM verwendet wird.
  *
  * @param   p_flag_in                   IN  Boolean-Wert zum Ein- bzw. Ausschalten von MTOM
  */
  PROCEDURE set_mtom_flag (p_flag_in IN BOOLEAN);
  
  /**
  * Gibt das Flag für MTOM zurück.
  *
  */
  FUNCTION get_mtom_flag RETURN BOOLEAN;
  
END «AttachmentContextPackageName()»;
/
«ENDFILE»

«FILE "plsql/" + getDBSchema("/") + AttachmentContextPackageName() + ".PKB"-»
CREATE OR REPLACE PACKAGE BODY «getDBSchema(".")»«AttachmentContextPackageName()»
/**
* <pre>
*
*  <br/>
*  Softwarekomponente:  api           -   Querschnittsfunktionalitäten für die API (Application Programming Interface)
*  <br/>
*
*  <b>Beschreibung:</b>
*  Dieses Package enthält Funktionalität, um Attachments zu verwalten, die als Binärdaten innerhalb von Soap-Requests übertragen werden.
*  !!! A C H T U N G  -- Modul ist generiert -- bitte nicht ändern !!!!
*
*  </pre>
*  @headcom
*  @CHECK  XXXX-XXXX  -- Checkprogramm für diese Komponente ausschalten
*
*  Änderungs-Historie:   (neue Einträge immer oben anfügen)
*  ========================================================
*  Revision  Wann      Wer              Was (Request und ASB / Störfall vermerken)
*  --------  --------  ---------------  ----------------------------------------
*  R1.0      27.09.19  M. Kiel          Neuerstellung des Packages
*/
IS
  
  -- Flag, ob MTOM für den aktuellen Service-Call verwendet werden soll
  g_use_mtom BOOLEAN DEFAULT FALSE;

  PROCEDURE add_attachment (p_attachment_in IN BLOB
                           ,p_mime_type_in IN VARCHAR2
                           ,p_filename_in IN VARCHAR
                           ,p_attachment_id_io IN OUT NOCOPY VARCHAR2)
  IS
     c_id_template CONSTANT VARCHAR2(18) := 'urn:ATTACHMENT_ID_';
     l_index                PLS_INTEGER;
  BEGIN
    g_attachment_obj.attachments.extend();
    l_index := g_attachment_obj.attachments.last;
    
    IF p_attachment_id_io IS NULL
    THEN
      p_attachment_id_io := c_id_template || to_char(l_index, 'fm0999999');
    END IF;
    
    g_attachment_obj.attachments(l_index) := NEW attachment_t (p_attachment_in, p_attachment_id_io, p_mime_type_in, p_filename_in);
  END add_attachment;
  
  FUNCTION get_attachment (f_attachment_id_in IN VARCHAR2)
    RETURN BLOB
  IS
    l_index PLS_INTEGER;
  BEGIN
    l_index := g_attachment_obj.attachments.first;
    <<suche_attachment>>
    WHILE l_index IS NOT NULL
    LOOP
      IF g_attachment_obj.attachments(l_index).contentId = f_attachment_id_in
      THEN
        EXIT suche_attachment;
      END IF;
      
      l_index := g_attachment_obj.attachments.next(l_index);
    END LOOP suche_attachment;
    
    IF l_index IS NOT NULL
    THEN
      RETURN g_attachment_obj.attachments(l_index).content;
    ELSE
      RETURN NULL;
    END IF;
  END get_attachment;
    
  PROCEDURE reset_attachments
  IS
  BEGIN
    g_attachment_obj := NEW soap_message_t (NEW attachment_ct());
  END reset_attachments;
  
  PROCEDURE set_mtom_flag (p_flag_in IN BOOLEAN)
  IS
  BEGIN
    g_use_mtom := p_flag_in;
  END set_mtom_flag;
  
  FUNCTION get_mtom_flag RETURN BOOLEAN
  IS
  BEGIN
    RETURN g_use_mtom;
  END get_mtom_flag;


END «AttachmentContextPackageName()»;
/
«ENDFILE»

«ENDIF»

«FILE "plsql/" + getDBSchema("/") + BasePackageName() + ".PKS"-»
CREATE OR REPLACE PACKAGE «getDBSchema(".")»«BasePackageName()» IS
/**
* <pre>
*
*  <b>Beschreibung:</b>
*  Dieses Package beinhaltet die Routinen, welche vom generierten Code verwendet werden.
*  !!! A C H T U N G  -- Modul ist generiert -- bitte nicht ändern !!!!
*  WSGenerate Version «getGeneratorVersion()» Build Time «getGeneratorBuildTime()»
*
*  </pre>
*
*  Änderungs-Historie:   (neue Einträge immer oben anfügen)
*  ========================================================
*  Revision  Wann      Wer              Was
*  --------  --------  ---------------  ----------------------------------------
*  R1.0      12.06.14  A.Karalus        Neuerstellung des Packages
*/

  ------------------------------------------------------------------------------
  -- öffentliche Typen und Konstanten
  ------------------------------------------------------------------------------

  SUBTYPE oraclename_T IS VARCHAR2(128);

  SUBTYPE maxplsqltext_T IS VARCHAR2(32767);
  c_fl_maxplsqltext CONSTANT PLS_INTEGER := 32767;

  ------------------------------------------------------------------------------
  -- TABLE Typen für die Verwendung von XSD Basistypen in <element/> mit maxOccurs="unbounded"
  -- (Voraussetzung: mapping.properties definiert Mapping 'orgW3Www2001=«BasePackageName()»')
  ------------------------------------------------------------------------------

  TYPE string_CT IS TABLE OF VARCHAR2(32767);
  TYPE int_CT IS TABLE OF INT;
  TYPE any_CT IS TABLE OF XMLTYPE;

  c_SOAP11_NS CONSTANT VARCHAR2(99) := 'http://schemas.xmlsoap.org/soap/envelope/';
  c_SOAP12_NS CONSTANT VARCHAR2(99) := 'http://www.w3.org/2003/05/soap-envelope';

  ------------------------------------------------------------------------------
  -- Prozeduren/Funktionen
  ------------------------------------------------------------------------------

  FUNCTION CHAR_TO_FLOAT(p_exp IN VARCHAR2) RETURN BINARY_FLOAT;
  FUNCTION FLOAT_TO_CHAR(p_n IN BINARY_FLOAT) RETURN VARCHAR2;
  FUNCTION CHAR_TO_DOUBLE(p_exp IN VARCHAR2) RETURN BINARY_DOUBLE;
  FUNCTION DOUBLE_TO_CHAR(p_n IN BINARY_DOUBLE) RETURN VARCHAR2;
  FUNCTION CHAR_TO_DURATION(p_exp IN VARCHAR2) RETURN INTERVAL DAY TO SECOND;
  FUNCTION DURATION_TO_CHAR(p_n IN INTERVAL DAY TO SECOND) RETURN VARCHAR2;
  FUNCTION DECIMAL_TO_CHAR(p_n IN NUMBER) RETURN VARCHAR2;

  /**
  * Ruft zum angebenen Service den entsprechenden Webservice auf.
  *
  * @param   p_url             <IN>    die Aufruf URL beim Service Gateway
  * @param   p_action          <IN>    die SOAPAction
  * @param   p_timeout         <IN>    der timeout in ms
  * @param   p_request         <IN>    die Daten fuer den SOAP Request im XML Format als CLOB
  *
  * @return  der SOAP Response im XML Format als CLOB
  */
  FUNCTION call_soap_http(p_url         IN VARCHAR2,
                          p_action      IN VARCHAR2,
                          p_timeout     IN INTEGER,
                          p_request     IN CLOB,
                          p_soap12      IN BOOLEAN DEFAULT FALSE) RETURN CLOB;


  /**
  * Erzeugt eine message Id.
  *
  */
  FUNCTION createMessageId RETURN VARCHAR2;


  /**
  * Erzeugt eine process instance Id.
  *
  */
  FUNCTION createProcessInstanceId RETURN VARCHAR2;


  /**
  * Füllt einen Textknoten mit dem Inhalt eines BLOB, der base64-codiert wird.
  *
  * @param   p_node             IN  Dom-Node, die mit dem Inhalt des BLOB gefüllt werden soll
  * @param   p_blob             IN  BLOB, der codiert wird
  */
  PROCEDURE fillTextNode(
    p_node  IN DBMS_XMLDOM.DOMNode
  , p_blob  IN BLOB);


  /**
  * Liest einen BLOB aus einem base64-codierten Textknoten.
  *
  * @param   p_node    IN  DOM-Node, die decodiert werden soll
  *
  * @return  BLOB mit dem Inhalt des decodierten Textknotens
  */
  FUNCTION getBlobFromNode(p_node IN DBMS_XMLDOM.DOMNode) RETURN BLOB;


  /**
  * Erzeugt aus dem Node einen XMLType.
  *
  * @param   p_node    IN  DOM-Node, die umgewandelt werden soll
  *
  * @return  XMLType-Repräsentation der Node
  */
  FUNCTION getXMLType(p_node IN DBMS_XMLDOM.DOMNode) RETURN XMLType;


  /**
  * Appended ein XMLType an einen Node.
  *
  * @param   p_xmltype      IN  XMLType, dessen Inhalt an die Node angehängt werden soll
  * @param   p_domdoc       IN  DOM-Document, in das der XML-Type eingefügt werden soll
  * @param   p_parent_node  IN  Knoten, der als Parent für den Inhalt des XMLType dienen soll
  */
  PROCEDURE appendXMLType(
    p_xmltype         IN XMLType
  , p_domdoc          IN DBMS_XMLDOM.DOMDocument
  , p_parent_node     IN DBMS_XMLDOM.DOMNode);


  /**
  * Gibt des Response-Code des zuletzt ausgeführten HTTP-Request zurück.
  *
  * @return  Response-Code
  */
  FUNCTION get_last_http_resp_code
    RETURN PLS_INTEGER;
    

  /**
  * Gibt die Aufruf-URL für den Service zurück.
  */
  FUNCTION getUrlForService (
      p_namespace           IN VARCHAR2
    , p_porttype            IN VARCHAR2
    , p_url                 IN VARCHAR2
  ) return VARCHAR2;


  /**
  * Signalisieren eines Fehlers in der internen XML-Verarbeitung.
  * Beim Mappen von XML -> PL/SQL ist ein unerwartetes ELement aufgetreten
  *
  * @param  p_element   IN    = Name des Elements
  */
  PROCEDURE fehler_unerwartetes_element (
      p_element         IN VARCHAR2
  );


  /**
  * Signalisieren eines Fehlers in der internen XML-Verarbeitung.
  * Beim Mappen von PL/SQL -> XML fehlt ein mandatorisches Element
  *
  * @param  p_element   IN    = Name des Elements
  */
  PROCEDURE fehler_pflichtelement_fehlt (
      p_element         IN VARCHAR2
  );
«IF mtomSupport()-»

  /**
  * Ruft zum angebenen Service den entsprechenden Webservice auf. Der Request wird dabei gemäß XOP-Spezifikation aufbereitet.
  *
  * @param   p_url             <IN>    die Aufruf URL beim Service Gateway
  * @param   p_action          <IN>    die SOAPAction
  * @param   p_timeout         <IN>    der timeout in ms
  * @param   p_request         <IN>    die Daten fuer den SOAP Request im XML Format als CLOB
  * @param   p_attachments     <IN>    die Attachments, die binär übertragen werden sollen
  *
  * @return  der SOAP Response im XML Format als CLOB
  */  
  FUNCTION call_soap_http_mtom (
    p_url         IN VARCHAR2,
    p_action      IN VARCHAR2,
    p_timeout     IN INTEGER,
    p_request     IN CLOB,
    p_attachments IN soap_message_t
  )
    RETURN CLOB;
  
  /**
  * Fügt den Binär-Inhalt als Referenz ein. Dazu wird ein neues Element xop:Include mit dem Namespace
  * xmlns:xop="http://www.w3.org/2004/08/xop/include" erzeugt. In dessen href-Attribut wird die ID des Attachments gespeichert. Der BLOB selbst
  * wird unter dieser ID durch das Package «AttachmentContextPackageName()» in einer globalen Variablen
  * vorgehalten.
  *
  * @param   p_domdoc           IN  Dom-Document
  * @param   p_node             IN  Dom-Node, unter der die Referenz gespeichert werden soll
  * @param   p_blob             IN  Binär-Daten als BLOB
  * @param   p_content_type     IN  Content-Type der Binärdaten
  * @param   p_filename         IN  Dateiname zum Attachment (optional)
  *
  */
  PROCEDURE appendBinaryContentAsRef (p_domdoc       IN DBMS_XMLDOM.DOMDocument
                                     ,p_node         IN DBMS_XMLDOM.DOMNode
                                     ,p_blob         IN BLOB
                                     ,p_content_type IN VARCHAR2
                                     ,p_filename     IN VARCHAR2 DEFAULT NULL);
                                     
  /**
  * Diese Funktion gibt die Binärdaten zurück, deren Referenz in der übergebenen Node gespeichert sind.
  *
  * @param   p_node             IN  Dom-Node, unter der die Referenz gespeichert ist
  *
  * @return  Binärdaten zur Referenz als BLOB
  */
  FUNCTION getBlobFromNodeWithRef (p_node IN DBMS_XMLDOM.DOMNode) 
    RETURN BLOB;
«ENDIF-»

END «BasePackageName()»;
/
«ENDFILE»


«FILE "plsql/" + getDBSchema("/") + BasePackageName() + ".PKB"-»
CREATE OR REPLACE PACKAGE BODY «getDBSchema(".")»«BasePackageName()» IS
/**
* <pre>
*
*  <b>Beschreibung:</b>
*  Dieses Package beinhaltet die Routinen, welche vom generierten Code verwendet werden.
*  !!! A C H T U N G  -- Modul ist generiert -- bitte nicht ändern !!!!
*	 WSGenerate Version «getGeneratorVersion()» Build Time «getGeneratorBuildTime()»
*
*  </pre>
*
*  Änderungs-Historie:   (neue Einträge immer oben anfügen)
*  ========================================================
*  Revision  Wann      Wer              Was
*  --------  --------  ---------------  ----------------------------------------
*  R1.0      12.06.14  A.Karalus        Neuerstellung des Packages
*/

  ------------------------------------------------------------------------------
  -- öffentliche Konstanten
  ------------------------------------------------------------------------------

  ------------------------------------------------------------------------------
  -- öffentliche Typen und Variablen
  ------------------------------------------------------------------------------
  g_charset                      oraclename_t := NULL;
  
  -- Response-Code des zuletzt ausgeführten HTTP-Requests
  g_http_response_code           PLS_INTEGER;
  
  -- Namespace für die Referenzierung von Binärinhalten als Attachment
  c_ns_xop_include     CONSTANT VARCHAR2(37) := 'http://www.w3.org/2004/08/xop/include';

  -- Content-Type für Multipart-Messages
  c_content_type_multipart CONSTANT VARCHAR2(17) := 'multipart/related';

  -- Content-Type für XOP
  c_content_type_xop       CONSTANT VARCHAR2(19) := 'application/xop+xml';

  -- Zeilenwechsel
  c_crlf CONSTANT VARCHAR2(2) := chr(13) || chr(10);

  ------------------------------------------------------------------------------
  -- globale Exceptions
  ------------------------------------------------------------------------------

  ------------------------------------------------------------------------------
  -- Private Prozeduren/Funktionen
  ------------------------------------------------------------------------------

  ------------------------------------------------------------------------------
  -- Standard Prozeduren/Funktionen
  ------------------------------------------------------------------------------

  FUNCTION CHAR_TO_FLOAT(p_exp IN VARCHAR2) RETURN BINARY_FLOAT IS
    v_result BINARY_FLOAT;
  BEGIN
    BEGIN
      -- Replace nötig, da wegen deutscher Sprache NLS_NUMERIC_CHARACTERS='',.'''
      v_result := TO_BINARY_FLOAT(REPLACE(p_exp,'.',','));
    EXCEPTION
      WHEN OTHERS THEN
        v_result := TO_BINARY_FLOAT(p_exp);
    END;
    RETURN v_result;
  END;

  FUNCTION FLOAT_TO_CHAR(p_n IN BINARY_FLOAT) RETURN VARCHAR2 IS
  BEGIN
    RETURN to_char(p_n, 'TMe', 'NLS_NUMERIC_CHARACTERS=''.,''');
  END;

  FUNCTION CHAR_TO_DOUBLE(p_exp IN VARCHAR2) RETURN BINARY_DOUBLE IS
    v_result BINARY_DOUBLE;
  BEGIN
    BEGIN
      -- Replace nötig, da wegen deutscher Sprache NLS_NUMERIC_CHARACTERS='',.'''
      v_result := TO_BINARY_DOUBLE(REPLACE(p_exp,'.',','));
    EXCEPTION
      WHEN OTHERS THEN
        v_result := TO_BINARY_DOUBLE(p_exp);
    END;
    RETURN v_result;
  END;

  FUNCTION DOUBLE_TO_CHAR(p_n IN BINARY_DOUBLE) RETURN VARCHAR2 IS
  BEGIN
    RETURN to_char(p_n, 'TMe', 'NLS_NUMERIC_CHARACTERS=''.,''');
  END;

  FUNCTION CHAR_TO_DURATION(p_exp IN VARCHAR2) RETURN INTERVAL DAY TO SECOND IS
    v_duration INTERVAL DAY TO SECOND;
  BEGIN
    -- TODO: Implementierung fehlt völlig, ggf. mit RegExp, siehe: http://www.w3.org/TR/2000/WD-xmlschema-2-20000225/#timeDuration
  	v_duration := '-7 19:24:30';
    RETURN v_duration;
  END;

  FUNCTION DURATION_TO_CHAR(p_n IN INTERVAL DAY TO SECOND) RETURN VARCHAR2 IS
    v_str  VARCHAR2(1);
    v_n    INTERVAL DAY TO SECOND;
  BEGIN
    IF p_n < INTERVAL '0' SECOND THEN
      v_str := '-';
      v_n := -1 * p_n;
    ELSE
      v_n := p_n;
    END IF;
    RETURN v_str || 'P0Y0M' || extract(DAY FROM v_n) || 'DT' || extract(HOUR FROM v_n) || 'H' || extract(MINUTE FROM v_n) || 'M' || to_char(extract(SECOND FROM v_n), 'fm00.000') || 'S';
  END;

  FUNCTION DECIMAL_TO_CHAR(p_n IN NUMBER) RETURN VARCHAR2 IS
    v_str  VARCHAR2(99);
  BEGIN
    v_str := TO_CHAR(p_n, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,''');
    IF SUBSTR(v_str, 1, 1) = '.' THEN
      v_str := '0' || v_str;
    ELSIF SUBSTR(v_str, 1, 2) = '-.' THEN
      v_str := '-0' || SUBSTR(v_str, 2);
    END IF;
    RETURN v_str;
  END;

  /**
  * Gibt des Response-Code des zuletzt ausgeführten HTTP-Request zurück.
  *
  * @return  Response-Code
  */
  FUNCTION get_last_http_resp_code
    RETURN PLS_INTEGER
  IS
  BEGIN
    RETURN g_http_response_code;
  END get_last_http_resp_code;

  /**
  * Ermittelt den Content-Type der Response und prüft auf eine MTOM-Nachricht. Als MTOM-Nachricht werden Responses erkannt,
  * die als Content-Type "multipart/related" und zusätzlich type="applicatiion/xop+xml" haben.
  *
  * @param   p_resp_io          <IN OUT>    HTTP-Response, aus der die Daten gelesen werden
  * @param   p_content_type_out <OUT>       HTTP-Header "Content-Type" aus der Response
  * @param   p_is_multipart_out <OUT>       Flag für MTOM-Nachricht
  *
  * @return  der SOAP Response im XML Format als CLOB
  */
  PROCEDURE get_response_content_type (p_resp_io          IN OUT NOCOPY utl_http.resp
                                      ,p_content_type_out OUT VARCHAR2
                                      ,p_is_multipart_out OUT BOOLEAN
  )
  IS
  BEGIN
    p_is_multipart_out := FALSE;

    utl_http.get_header_by_name (r     => p_resp_io,
                                 name  => 'Content-Type',
                                 value => p_content_type_out,
                                 n     => 1);

    IF p_content_type_out IS NOT NULL
      AND p_content_type_out LIKE c_content_type_multipart || '%'
      AND instr (p_content_type_out, 'type="' || c_content_type_xop || '"') > 0
    THEN
      p_is_multipart_out := TRUE;
    END IF;
  END get_response_content_type;

  PROCEDURE setBasicAuthCredential(
    p_url IN VARCHAR2,
    p_http_request IN OUT NOCOPY UTL_HTTP.req
  ) IS
  BEGIN
    «BasePackage_setBasicAuthCredential()»
  END;

«IF mtomSupport()-»
  /**
  * Decodiert die Response im MTOM/XOP-Format und gibt die XML-Nachricht zurück. Falls binäre Attachments
  * enthalten sind werden diese an das Package «AttachmentContextPackageName()» übergeben.
  *
  * @param   p_resp_io         <IN OUT>    HTTP-Response, aus der die Daten gelesen werden
  * @param   p_content_type_in <IN>        HTTP-Header "Content-Type" aus der Response
  * @param   p_xml_msg_io      <IN OUT>    Extrahierte XML-Nachricht
  *
  * @return  der SOAP Response im XML Format als CLOB
  */
  PROCEDURE decode_mtom_response (p_resp_io          IN OUT NOCOPY utl_http.resp
                                 ,p_content_type_in  IN VARCHAR2
                                 ,p_xml_msg_io       IN OUT NOCOPY CLOB)
  IS
    l_chunk    RAW(32767);
    l_raw_resp BLOB;
    l_boundary VARCHAR2(1000);
    l_boundary_raw RAW(1000);
    l_pos      INTEGER;
    l_pos2     INTEGER;
    l_pos3     INTEGER;

    c_double_crlf CONSTANT RAW(4) := utl_raw.cast_to_raw (c_crlf || c_crlf);

    l_header_part VARCHAR2(4000);
    l_encoding    VARCHAR2(20);
    l_csid        PLS_INTEGER;
    l_lang_ctx    PLS_INTEGER := 0;
    l_warn        VARCHAR2(4000);
    l_dest_offset INTEGER := 1;
    l_src_offset  INTEGER;
    l_pos_ende    INTEGER;
    l_content_type VARCHAR2(255);
    l_att_id       VARCHAR2(1000);
    l_attachment   BLOB;
    c_routine CONSTANT oraclename_t := 'decode_mtom_response';
  BEGIN
    -- Gesamte Response-Nachricht in einen BLOB einlesen
    dbms_lob.createtemporary (l_raw_resp, TRUE, dbms_lob.call);
    BEGIN
      LOOP
        utl_http.read_raw (p_resp_io, l_chunk);
        dbms_lob.writeappend(l_raw_resp, utl_raw.length(l_chunk), l_chunk);
      END LOOP;
    EXCEPTION
      WHEN utl_http.end_of_body
      THEN
        NULL;
    END;

    -- Boundary-String aus Content-Type ermitteln
    l_boundary := regexp_substr (srcstr => p_content_type_in, pattern => 'boundary="([^"]+)"',subexpression => 1);

    IF l_boundary IS NULL
    THEN
      RAISE_APPLICATION_ERROR(-20004, 'Ungültiger Content Type Header - boundary nicht gefunden.');
    END IF;

    -- Suchmuster für Boundary erzeugen: in der Nachricht wird der Boundary-String mit vorangestelltem "--" verwendet
    l_boundary_raw := utl_raw.cast_to_raw('--' || l_boundary);

    -- Erste Position des Boundaries ermitteln
    l_pos := dbms_lob.instr (l_raw_resp, l_boundary_raw);

    IF l_pos = 0
    THEN
      RAISE_APPLICATION_ERROR(-20005, 'Fehler beim Parsen der Nachricht [1]: boundary wurde in der Nachricht nicht gefunden.');
    END IF;

    -- Position des doppelten Zeilenwechsels nach dem ersten Boundary -> markiert Ende des Headers des ersten Teils und somit den Anfang
    -- der Daten des ersten Teils
    l_pos2 := dbms_lob.instr(lob_loc => l_raw_resp,
                             pattern => c_double_crlf,
                             offset  => l_pos + 1,
                             nth     => 1);

    IF l_pos2 = 0
    THEN
      RAISE_APPLICATION_ERROR(-20006, 'Fehler beim Parsen der Nachricht [2]: Nachrichten-Header muss mit doppeltem CRLF abgeschlossen werden.');
    END IF;

    -- Header des ersten Teils extrahieren
    l_header_part := utl_raw.cast_to_varchar2 (dbms_lob.substr (l_raw_resp,l_pos2 - l_pos - 1,l_pos + 1));

    -- Encoding aus Header ermitteln
    l_encoding := regexp_substr (srcstr => l_header_part,pattern => '^Content-Type: .*charset=([A-Za-z0-9\-]+)',modifier => 'm',subexpression => 1);

    IF l_encoding IS NULL
    THEN
      RAISE_APPLICATION_ERROR(-20007, 'Fehler beim Parsen der Nachricht [3]: Angabe zu charset wurde in erstem Nachrichten-Teil nicht geunden');
    END IF;

    -- bei den nächsten Boundaries wird zusätzlich auf einen vorangestellten Zeilenwechsel geprüft
    l_boundary_raw := utl_raw.cast_to_raw(chr(10) || '--' || l_boundary);

    -- Nächst folge Boundary ermitteln
    l_pos3 := dbms_lob.instr (lob_loc => l_raw_resp,
                              pattern => l_boundary_raw,
                              offset  => l_pos2 + 4,
                              nth     => 1);
    IF l_pos3 = 0
    THEN
      RAISE_APPLICATION_ERROR(-20005, 'Fehler beim Parsen der Nachricht [4]: boundary wurde in der Nachricht nicht gefunden.');
    END IF;

    -- interne Charset-ID zum Encoding des ersten Nachrichten-Teils ermitteln
    l_csid := nls_charset_id (CASE upper (l_encoding)
                               WHEN 'UTF-8' THEN 'AL32UTF8'
                               WHEN 'WINDOWS-1252' THEN 'WE8MSWIN1252'
                               WHEN 'ISO-8859-15' THEN 'WE8ISO8859P15'
                               WHEN 'ISO-8859-1' THEN 'WE8ISO8859P1'
                              END);

    IF l_csid IS NULL
    THEN
      RAISE_APPLICATION_ERROR(-20008, 'Fehler beim Parsen der Nachricht [5]: Nicht unterstützter Zeichensatz ' || l_encoding);
    END IF;

    -- Beginn ist die Position des doppelten Zeilenwechsels + 4 Bytes, die der doppelte Zeilenwechsel einnimmt
    l_src_offset := l_pos2 + 4;
    -- XML-Nachricht in CLOB extrahieren
    dbms_lob.convertToClob (dest_lob     => p_xml_msg_io,
                            src_blob     => l_raw_resp,
                            amount       => l_pos3 - l_pos2 - 5,
                            dest_offset  => l_dest_offset,
                            src_offset   => l_src_offset,
                            blob_csid    => l_csid,
                            lang_context => l_lang_ctx,
                            warning      => l_warn);

    -- Position der End-Boundary ermitteln
    l_pos_ende := dbms_lob.instr(lob_loc => l_raw_resp,
                                 pattern => utl_raw.cast_to_raw(chr(10) || '--' || l_boundary || '--'),
                                 offset  => l_pos2 + 4,
                                 nth     => 1);

    IF l_pos_ende = 0
    THEN
      RAISE_APPLICATION_ERROR(-20009, 'Fehler beim Parsen der Nachricht [6]: Ende-Kennzeichen wurde in der Nachricht nicht gefunden.');
    END IF;

    dbms_lob.createtemporary (l_attachment, TRUE, dbms_lob.call);

    «AttachmentContextPackageName()».reset_attachments;

    -- Attachments extrahieren
    <<extract_attachments>>
    LOOP
      -- Schleife beenden, wenn die Position des End-Boundaries gefunden wurde
      EXIT extract_attachments WHEN l_pos3 = l_pos_ende;

      l_pos := l_pos3;
      -- Doppelter Zeilenwechsel nach dem Boundary
      l_pos2 := dbms_lob.instr(lob_loc => l_raw_resp,
                               pattern => c_double_crlf,
                               offset  => l_pos + 1,
                               nth     => 1);
      IF l_pos2 = 0
      THEN
        RAISE_APPLICATION_ERROR(-20006, 'Fehler beim Parsen der Nachricht [7]: Nachrichten-Header muss mit doppeltem CRLF abgeschlossen werden.');
      END IF;

      -- Headeer extrahieren
      l_header_part := utl_raw.cast_to_varchar2 (dbms_lob.substr (l_raw_resp,l_pos2 - l_pos - 1,l_pos + 1));

      -- Content-Type aus Header extrahieren
      l_content_type := regexp_substr (srcstr => l_header_part, pattern => '^Content-Type: (\S+)',modifier => 'm',subexpression => 1);

      -- Content-ID aus Header extrahieren
      l_att_id := regexp_substr (srcstr => l_header_part, pattern => '^Content-ID: <(\S+)>',modifier => 'm',subexpression => 1);

      IF l_att_id IS NULL
      THEN
        RAISE_APPLICATION_ERROR(-20010, 'Fehler beim Parsen der Nachricht [8]: Content-ID wurde in Header nicht gefunden.');
      END IF;

      -- Nächste Boundary ermitteln
      l_pos3 := dbms_lob.instr (lob_loc => l_raw_resp,
                                pattern => l_boundary_raw,
                                offset  => l_pos2,
                                nth     => 1);

      IF l_pos3 = 0
      THEN
        RAISE_APPLICATION_ERROR(-20005, 'Fehler beim Parsen der Nachricht [9]: boundary wurde in der Nachricht nicht gefunden.');
      END IF;

      l_dest_offset := 1;
      l_src_offset := l_pos2 + 4;

      -- Attachment in BLOB kopieren
      dbms_lob.copy(dest_lob    => l_attachment,
                    src_lob     => l_raw_resp,
                    amount      => l_pos3 - l_pos2 - 5,
                    dest_offset => l_dest_offset,
                    src_offset  => l_src_offset);

      -- Attachment speichern
      «AttachmentContextPackageName()».add_attachment(p_attachment_in    => l_attachment,
                                                p_mime_type_in     => l_content_type,
                                                p_filename_in      => NULL,
                                                p_attachment_id_io => l_att_id);
    END LOOP;

    dbms_lob.freetemporary (l_raw_resp);
  END decode_mtom_response;

«ENDIF-»

  FUNCTION call_soap_http(
    p_url         IN VARCHAR2,
    p_action      IN VARCHAR2,
    p_timeout     IN INTEGER,
    p_request     IN CLOB,
    p_soap12      IN BOOLEAN)
  RETURN CLOB AS
    l_blob         BLOB;
    l_dest_offset  INTEGER := 1;
    l_src_offset   INTEGER := 1;
    l_lang_context INTEGER := 0;
    l_warning      INTEGER;
    l_blob_length  INTEGER;

    v_http_request    UTL_HTTP.req;
    v_http_response   UTL_HTTP.resp;
    v_response        CLOB;

    v_response_line   VARCHAR2(32767);
    v_zaehler         INTEGER := 1;
    v_content_type    VARCHAR2(1000);
    v_is_mtom         BOOLEAN;
  BEGIN
    -- Variable für Response-Code zurücksetzen
    g_http_response_code := NULL;
«IF mtomSupport()-»

    -- Flag für MTOM auf FALSE zurücksetzen
    «AttachmentContextPackageName()».set_mtom_flag(FALSE);

«ENDIF-»

    IF g_charset IS NULL THEN
      SELECT VALUE INTO g_charset FROM NLS_DATABASE_PARAMETERS WHERE PARAMETER = 'NLS_CHARACTERSET';
      CASE
        WHEN g_charset = 'WE8ISO8859P1'  THEN g_charset := 'iso-8859-1';
        WHEN g_charset = 'WE8ISO8859P15' THEN g_charset := 'iso-8859-15';
        WHEN g_charset = 'WE8MSWIN1252'  THEN g_charset := 'windows-1252';
        WHEN g_charset IN ('AL32UTF8','UTF8') THEN g_charset := 'utf-8';
        ELSE RAISE_APPLICATION_ERROR(-20003, 'Database charset not supported: ' || g_charset);
      END CASE;
    END IF;

    IF p_url IS NULL OR p_url NOT LIKE 'http%' THEN
      RAISE_APPLICATION_ERROR(-20002, 'Fehler keine korrekte URL: ' || p_url);
    END IF;

    dbms_lob.createTemporary(l_blob, TRUE, dbms_lob.call);
    dbms_lob.convertToBlob(dest_lob     => l_blob,
                           src_clob     => p_request,
                           amount       => dbms_lob.lobmaxsize,
                           dest_offset  => l_dest_offset,
                           src_offset   => l_src_offset,
                           blob_csid    => nls_charset_id('AL32UTF8'),
                           lang_context => l_lang_context,
                           warning      => l_warning);
    l_blob_length := dbms_lob.getlength(l_blob);

    v_http_request := UTL_HTTP.begin_request(p_url, 'POST', 'HTTP/1.1');

    IF p_timeout IS NOT NULL THEN
      UTL_HTTP.set_transfer_timeout(v_http_request, p_timeout / 1000);
    END IF;
    UTL_HTTP.set_response_error_check(v_http_request, FALSE);
    IF p_soap12 THEN
      UTL_HTTP.set_header(v_http_request, 'Content-Type', 'application/soap+xml; charset=utf-8; action=' || p_action);
    ELSE
      UTL_HTTP.set_header(v_http_request, 'Content-Type', 'text/xml; charset=utf-8');
      UTL_HTTP.set_header(v_http_request, 'SOAPAction', p_action);
    END IF;
    UTL_HTTP.set_header(v_http_request, 'Content-Length', l_blob_length);
    -- Response im Charset der Datenbank anfordern
    UTL_HTTP.set_header(v_http_request, 'Accept-Charset', g_charset);
    setBasicAuthCredential(p_url, v_http_request);

    -- write_raw kann nur 32 K pro Aufruf schreiben, deshalb mehrmaliger
    -- Aufruf um auch groessere Datenmengen uebergeben zu koennen.
    WHILE v_zaehler <= l_blob_length
    LOOP
      UTL_HTTP.write_raw(v_http_request, DBMS_LOB.SUBSTR(l_blob, 32767, v_zaehler));
      v_zaehler := v_zaehler + 32767;
    END LOOP;
    dbms_lob.freeTemporary(l_blob);

    v_http_response := UTL_HTTP.get_response(v_http_request);
    
    -- Response-Code in interner Variable speichern
    g_http_response_code := v_http_response.status_code;

    -- Pruefen auf ReturnCode
    IF v_http_response.status_code != UTL_HTTP.HTTP_OK AND v_http_response.status_code != 500 THEN
      UTL_HTTP.end_response(v_http_response);
      RAISE_APPLICATION_ERROR(-20001, 'Fehler ' || v_http_response.status_code || ' ' || v_http_response.reason_phrase || ' beim Http Request');
    END IF;

    -- Content-Type der Response ermitteln und auf MTOM prüfen
    get_response_content_type (v_http_response, v_content_type, v_is_mtom);

    -- Initialisierung des CLOB.
    DBMS_LOB.createTemporary(v_response, TRUE, dbms_lob.call);

    IF v_is_mtom
    THEN
«IF mtomSupport()-»
      decode_mtom_response (v_http_response, v_content_type, v_response);
      «AttachmentContextPackageName()».set_mtom_flag(TRUE);
«ELSE-»
      -- MTOM wird nicht benötigt
      NULL;
«ENDIF-»
    ELSE
      -- Das Ergebnis wird in einer Schleife ausgelesen
      -- Es werden immer 32K grosse Teile der Antwort ausgelesen.
      -- In der Exception wird, wenn die Antwort ausgelesen wurde, der Response geschlossen
      BEGIN
        LOOP
          UTL_HTTP.read_text(v_http_response, v_response_line);
          DBMS_LOB.writeappend(v_response, LENGTH(v_response_line), v_response_line);
        END LOOP;
      EXCEPTION
        WHEN UTL_HTTP.end_of_body THEN
          UTL_HTTP.end_response(v_http_response);
      END;
    END IF;

    return v_response;

  END call_soap_http;

  /**
  * Erzeugt eine neue MessageId.
  * Wird intern benötigt wenn ein C-Package aufgerufen wird.
  *
  * @return   = MessageId
  */
  FUNCTION createMessageId RETURN VARCHAR2 AS
    v_sys_guid RAW(32) := SYS_GUID();
  BEGIN
    return rpad('M-' || substr(v_sys_guid,1,8) || '-' || substr(v_sys_guid,9,4) || '-' || substr(v_sys_guid,13,4) || '-' || substr(v_sys_guid,17,4) || '-' || substr(v_sys_guid,21),38,'0');
  END createMessageId;


  /**
  * Erzeugt eine neue ProcessInstanceId.
  * Wird benötigt wenn ein Geschäftsprozess initiert wird.
  * Sollte man bereits vom Service Gateway aufgerufen werden, ist die einkommenden ProcessInstanceId weiterzuverwenden (geschachtelter Aufruf).
  *
  * @return   = ProcessInstanceId
  */
  FUNCTION createProcessInstanceId RETURN VARCHAR2 AS
    v_sys_guid RAW(32) := SYS_GUID();
  BEGIN
    return rpad('P-' || substr(v_sys_guid,1,8) || '-' || substr(v_sys_guid,9,4) || '-' || substr(v_sys_guid,13,4) || '-' || substr(v_sys_guid,17,4) || '-' || substr(v_sys_guid,21),38,'0');
  END createProcessInstanceId;


  -- https://community.oracle.com/thread/1026102
  PROCEDURE fillTextNode(
    p_node  IN DBMS_XMLDOM.DOMNode
  , p_blob  IN BLOB) IS

    bloblen    CONSTANT INTEGER := dbms_lob.getlength(p_blob);

    ostream    sys.utl_CharacterOutputStream;
    chunksize  CONSTANT INTEGER := 57;
    offset     integer := 1;
    chunk      raw(57);
    chunk_b64  varchar2(78);
    dummy      integer;
  BEGIN
    ostream := DBMS_XMLDOM.setNodeValueAsCharacterStream(p_node);

    while offset < bloblen
    loop
      chunk := DBMS_LOB.SUBSTR(p_blob, chunksize, offset);
      chunk_b64 := utl_raw.cast_to_varchar2(utl_encode.base64_encode(chunk));
      -- write chunk to DOM node
      dummy := ostream.write(chunk_b64, length(chunk_b64));
      offset := offset + chunksize;
    end loop;

    ostream.close();

  END fillTextNode;


  FUNCTION getBlobFromNode(p_node IN DBMS_XMLDOM.DOMNode) RETURN BLOB AS

    v_istream                     SYS.utl_CharacterInputStream;
    v_response                    BLOB;
    v_chunksize                   integer := 16384;
    v_chunk                       varchar2(16384);
    v_offset                      integer := 0;
    v_char                        char;
    v_count                       integer := 0;
    v_lastValid                   integer;
    v_buffer                      raw(12288);
  BEGIN
    v_istream := DBMS_XMLDOM.getNodeValueAsCharacterStream(p_node);
    DBMS_LOB.createTemporary(v_response, TRUE, dbms_lob.call);
    IF NOT v_istream.isnull() THEN
      -- Read stream in chunks
      LOOP
         v_chunksize := 16384 - v_offset;
         v_istream.read(v_chunk, v_offset, v_chunksize);
         EXIT WHEN v_chunksize <= 0;
         -- Find last valid end of a 4 char block
         v_lastValid := 0;
         FOR v_pos IN 1 + v_offset..length(v_chunk)
         LOOP
            v_char := substr(v_chunk, v_pos, 1);
            IF ASCII(v_char) > 32 AND ASCII(v_char) < 128 THEN
               v_count := v_count + 1;
            END IF;
            IF BITAND(v_count, 3) = 0 THEN
               v_lastValid := v_pos;
            END IF;
         END LOOP;
         EXIT WHEN v_lastValid = 0;
         v_offset := length(v_chunk) - v_lastValid;
         IF v_offset > 0 THEN
            v_buffer := utl_encode.base64_decode(utl_raw.cast_to_raw(substr(v_chunk, 1, v_lastValid)));
            -- Take remaining chars into next iteration
            v_chunk := substr(v_chunk, v_lastValid + 1, v_offset);
         ELSE
            v_buffer := utl_encode.base64_decode(utl_raw.cast_to_raw(v_chunk));
         END IF;
         DBMS_LOB.writeappend(v_response, utl_raw.length(v_buffer), v_buffer);
      END LOOP;
    END IF;
    v_istream.close();
    return v_response;
  END getBlobFromNode;

  
  FUNCTION getXMLType(p_node IN DBMS_XMLDOM.DOMNode) RETURN XMLType AS
    v_doc                        DBMS_XMLDOM.DOMDocument;
    v_node                       DBMS_XMLDOM.DOMNode;
    v_result                     XMLType;
  BEGIN
    IF NOT DBMS_XMLDOM.isNull(p_node) THEN
      v_doc := DBMS_XMLDOM.newDOMDocument;
      v_node := DBMS_XMLDOM.appendChild(DBMS_XMLDOM.makeNode(v_doc), DBMS_XMLDOM.adoptNode(v_doc, p_node));
      v_result := DBMS_XMLDOM.getXMLType(v_doc);
      DBMS_XMLDOM.freeDocument(v_doc);
    END IF;

    return v_result;
  END;


  PROCEDURE appendXMLType(
    p_xmltype         IN XMLType
  , p_domdoc          IN DBMS_XMLDOM.DOMDocument
  , p_parent_node     IN DBMS_XMLDOM.DOMNode) IS

    v_doc                        DBMS_XMLDOM.DOMDocument;
    v_node                       DBMS_XMLDOM.DOMNode;
  BEGIN
    v_doc := DBMS_XMLDOM.newDOMDocument(p_xmltype);
    v_node := DBMS_XMLDOM.appendChild(p_parent_node, DBMS_XMLDOM.adoptNode(p_domdoc, DBMS_XMLDOM.makeNode(DBMS_XMLDOM.getDocumentElement(v_doc))));
    DBMS_XMLDOM.freeDocument(v_doc);
  END;
  
  /**
  * Signalisieren eines Fehlers in der internen XML-Verarbeitung.
  * Beim Mappen von XML -> PL/SQL ist ein unerwartetes ELement aufgetreten
  *
  * @param  p_element   IN    = Name des Elements
  */
  PROCEDURE fehler_unerwartetes_element (
      p_element         IN VARCHAR2
  ) IS
  BEGIN
     RAISE_APPLICATION_ERROR(-20000, 'Unerwartetes Element <' || p_element || '> in der IN-Struktur.');
  END;


  /**
  * Gibt die Aufruf-URL für den Service zurück.
  */
  FUNCTION getUrlForService (
      p_namespace           IN VARCHAR2
    , p_porttype            IN VARCHAR2
    , p_url                 IN VARCHAR2
  ) return VARCHAR2 IS
  BEGIN
 «IF BasePackage_getUrlForServiceDelegate() != null-»
 	return «BasePackage_getUrlForServiceDelegate()»;
 «ELSE-»
    -- TODO: Muss fuer jedes System implementiert werden, ist umgebungsabhängig!
	
    IF p_url IS NULL THEN
       RAISE_APPLICATION_ERROR(-20010, 'No URL given');
    END IF;
    return p_url;
 «ENDIF-»
  END;


  /**
  * Signalisieren eines Fehlers in der internen XML-Verarbeitung.
  * Beim Mappen von PL/SQL -> XML fehlt ein mandatorisches Element
  *
  * @param  p_element   IN    = Name des Elements
  */
  PROCEDURE fehler_pflichtelement_fehlt (
      p_element         IN VARCHAR2
  ) IS
  BEGIN
     RAISE_APPLICATION_ERROR(-20001, 'Pflichtelement <' || p_element || '> fehlt in der OUT-Struktur.');
  END;
«IF mtomSupport()-»

  /**
  * Fügt den Binär-Inhalt als Referenz ein. Dazu wird ein neues Element xop:Include mit dem Namespace
  * xmlns:xop="http://www.w3.org/2004/08/xop/include" erzeugt. In dessen href-Attribut wird die ID des Attachments gespeichert. Der BLOB selbst
  * wird unter dieser ID durch das Package «AttachmentContextPackageName()» in einer globalen Variablen
  * vorgehalten.
  *
  * @param   p_domdoc           IN  Dom-Document
  * @param   p_node             IN  Dom-Node, unter der die Referenz gespeichert werden soll
  * @param   p_blob             IN  Binär-Daten als BLOB
  * @param   p_filename         IN  Dateiname zum Attachment (optional)
  *
  */
  PROCEDURE appendBinaryContentAsRef (p_domdoc       IN DBMS_XMLDOM.DOMDocument
                                     ,p_node         IN DBMS_XMLDOM.DOMNode
                                     ,p_blob         IN BLOB
                                     ,p_content_type IN VARCHAR2
                                     ,p_filename     IN VARCHAR2 DEFAULT NULL)
  IS
    l_id VARCHAR2(255);
    l_element DBMS_XMLDOM.DOMElement;
    l_node DBMS_XMLDOM.DOMNode;
  BEGIN
    -- Binary Content in «AttachmentContextPackageName()» speichern und ID generieren
    «AttachmentContextPackageName()».add_attachment(p_attachment_in => p_blob
                                             ,p_mime_type_in => p_content_type
                                             ,p_filename_in => p_filename
                                             ,p_attachment_id_io => l_id);

    -- Element anlegen, unter der die ID als Attribut gespeichert wird
    l_element := DBMS_XMLDOM.createElement(p_domdoc, 'xop:Include', c_ns_xop_include);
    DBMS_XMLDOM.setAttribute(l_element, 'xmlns:xop', c_ns_xop_include);
    DBMS_XMLDOM.setAttribute(l_element, 'href', 'cid:' || l_id); -- R4.17
    -- Element zur übergebenen Node hinzufügen
    l_node := DBMS_XMLDOM.appendChild(p_node, DBMS_XMLDOM.makeNode(l_element));

  END appendBinaryContentAsRef;


  /**
  * Diese Funktion gibt die Binärdaten zurück, deren Referenz in der übergebenen Node gespeichert sind.
  *
  * @param   p_node             IN  Dom-Node, unter der die Referenz gespeichert ist
  *
  * @return  Binärdaten zur Referenz als BLOB
  */
  FUNCTION getBlobFromNodeWithRef (p_node IN DBMS_XMLDOM.DOMNode)
  RETURN BLOB
  IS
    l_id VARCHAR2(255);
    l_element DBMS_XMLDOM.DOMElement;
  BEGIN
    l_element := DBMS_XMLDOM.makeElement (p_node);

    -- Prüfen, ob es sich um das Element "Include" aus dem Namespace http://www.w3.org/2004/08/xop/include
    -- handelt
    IF DBMS_XMLDOM.getLocalName(l_element) = 'Include' AND DBMS_XMLDOM.getNamespace(l_element) = c_ns_xop_include
    THEN
      -- Falls ja, dann Wert des Attribus "href" ermittelt - dieses enthält die ID, unter der die Binärdaten abgelegt sind
      -- R4.18: Falls der String "cid:" der ID vorangestellt ist wird dieser weggeschnitten
      l_id := regexp_replace (DBMS_XMLDOM.getAttribute (l_element, 'href'), '^cid:');
    END IF;

    IF l_id IS NOT NULL
    THEN
      -- Binärdaten zur ID ermitteln und zurückgeben
      RETURN «AttachmentContextPackageName()».get_attachment (l_id);
    ELSE
      -- Falls keine ID ermittelt werden konnte dann NULL zurückgeben
      RETURN NULL;
    END IF;
  END getBlobFromNodeWithRef;

  /**
  * Ruft zum angebenen Service den entsprechenden Webservice auf. Der Request wird dabei gemäß XOP-Spezifikation aufbereitet.
  *
  * @param   p_url             <IN>    die Aufruf URL beim Service Gateway
  * @param   p_action          <IN>    die SOAPAction
  * @param   p_timeout         <IN>    der timeout in ms
  * @param   p_request         <IN>    die Daten fuer den SOAP Request im XML Format als CLOB
  * @param   p_attachments     <IN>    die Attachments, die binär übertragen werden sollen
  *
  * @return  der SOAP Response im XML Format als CLOB
  */
  FUNCTION call_soap_http_mtom (
    p_url              IN VARCHAR2,
    p_action           IN VARCHAR2,
    p_timeout          IN INTEGER,
    p_request          IN CLOB,
    p_attachments      IN soap_message_t
  )
  RETURN CLOB AS
    c_routine CONSTANT oraclename_t := 'call_soap_http_mtom';

    l_blob         BLOB;
    l_dest_offset  INTEGER := 1;
    l_src_offset   INTEGER := 1;
    l_lang_context INTEGER := 0;
    l_warning      INTEGER;
    l_blob_length  INTEGER;

    v_http_request    UTL_HTTP.req;
    v_http_response   UTL_HTTP.resp;
    v_response        CLOB;

    v_response_line   VARCHAR2(32767);
    v_zaehler         INTEGER := 1;

    -- Konstanten für den Aufbau der XOP-Message
    --
    -- Trenner zwischen den Parts
    c_boundary               CONSTANT VARCHAR2(255) := '----=_Part_941_406332184.1567595604772';

    -- Content-Type für XML
    c_type_xml               CONSTANT VARCHAR2(8) := 'text/xml';

    -- Header des ersten XOP-Parts
    -- ------=_Part_941_406332184.1567595604772
    -- Content-Type: application/xop+xml; type=text/xml; charset=UTF-8
    c_begin_part CONSTANT VARCHAR2(255) :=
                 '--' ||
                 c_boundary ||
                 c_crlf ||
                 'Content-Type: ' ||
                 c_content_type_xop ||
                 '; type=' || c_type_xml || '; charset=UTF-8'||
                 c_crlf ||
                 c_crlf;

     l_begin_part RAW(255);
     l_begin_binary_part VARCHAR2(255);
     l_attachment_index PLS_INTEGER;

     v_content_type    VARCHAR2(1000);
     v_is_mtom         BOOLEAN;
     v_req_context     utl_http.request_context_key;
  BEGIN
    -- Variable für Response-Code zurücksetzen
    g_http_response_code := NULL;

    -- Flag für MTOM auf FALSE zurücksetzen
    «AttachmentContextPackageName()».set_mtom_flag(FALSE);

    IF g_charset IS NULL THEN
      SELECT VALUE INTO g_charset FROM NLS_DATABASE_PARAMETERS WHERE PARAMETER = 'NLS_CHARACTERSET';
      CASE
        WHEN g_charset = 'WE8ISO8859P1'  THEN g_charset := 'iso-8859-1';
        WHEN g_charset = 'WE8ISO8859P15' THEN g_charset := 'iso-8859-15';
        WHEN g_charset = 'WE8MSWIN1252'  THEN g_charset := 'windows-1252';
        WHEN g_charset IN ('AL32UTF8','UTF8') THEN g_charset := 'utf-8'; --R4.11
        ELSE RAISE_APPLICATION_ERROR(-20003, 'Database charset not supported: ' || g_charset);
      END CASE;
    END IF;

    IF p_url IS NULL OR p_url NOT LIKE 'http%' THEN
      RAISE_APPLICATION_ERROR(-20002, 'Fehler keine korrekte URL: ' || p_url);
    END IF;

    dbms_lob.createTemporary(l_blob, TRUE, dbms_lob.call);

    l_begin_part := utl_raw.cast_to_raw (c_begin_part);

    -- Header des ersten XOP-Parts vor dem eigentlichen Request einfügen
    dbms_lob.writeappend (lob_loc => l_blob
                         ,amount => utl_raw.length (l_begin_part)
                         ,buffer => l_begin_part);

    l_dest_offset := dbms_lob.getlength (l_blob) + 1;

    -- SOAP-Request in Blob konvertieren und in den Ziel-Blob schreiben
    dbms_lob.convertToBlob(dest_lob     => l_blob,
                           src_clob     => p_request,
                           amount       => dbms_lob.lobmaxsize,
                           dest_offset  => l_dest_offset,
                           src_offset   => l_src_offset,
                           blob_csid    => nls_charset_id('AL32UTF8'),
                           lang_context => l_lang_context,
                           warning      => l_warning);

    -- Attachments verarbeiten
    IF p_attachments IS NOT NULL
    THEN
      l_attachment_index := p_attachments.attachments.first;

      WHILE l_attachment_index IS NOT NULL
      LOOP
        -- Heander für Attachment erzeugen
        l_begin_binary_part := c_crlf ||
         '--' || c_boundary || c_crlf ||
         'Content-Type: ' || p_attachments.attachments(l_attachment_index).contentType || c_crlf ||
         'Content-Transfer-Encoding: binary' || c_crlf ||
         'Content-ID: ' || '<' || p_attachments.attachments(l_attachment_index).contentId || '>' || c_crlf || c_crlf;

        l_begin_part := utl_raw.cast_to_raw (l_begin_binary_part);

        -- Header in den Blob schreiben
        dbms_lob.writeappend (lob_loc => l_blob
                             ,amount => utl_raw.length (l_begin_part)
                             ,buffer => l_begin_part);

        l_dest_offset := dbms_lob.getlength (l_blob) + 1;
        l_src_offset := 1;

        -- Attachment in den Blob kopieren
        dbms_lob.copy (dest_lob => l_blob
                      ,src_lob => p_attachments.attachments(l_attachment_index).content
                      ,amount => dbms_lob.lobmaxsize
                      ,dest_offset => l_dest_offset
                      ,src_offset => l_src_offset);

        l_attachment_index := p_attachments.attachments.next (l_attachment_index);
      END LOOP;
    END IF;

    -- Ende-Kennzeichnung hat 2 Minus-Zeichen am Anfang und 2 am Ende
    l_begin_binary_part := c_crlf ||
       '--' || c_boundary || '--' || c_crlf;

    l_begin_part := utl_raw.cast_to_raw (l_begin_binary_part);

    -- Ende-Kennzeichnung schreiben
    dbms_lob.writeappend (lob_loc => l_blob
                         ,amount => utl_raw.length (l_begin_part)
                         ,buffer => l_begin_part);

    l_blob_length := dbms_lob.getlength(l_blob);

    IF p_url LIKE 'https://%'
    THEN
      v_http_request := UTL_HTTP.begin_request(url             => p_url,
                                               method          => 'POST',
                                               http_version    => 'HTTP/1.1');
    ELSE
      v_http_request := UTL_HTTP.begin_request(p_url, 'POST', 'HTTP/1.1');  
    END IF;

    IF p_timeout IS NOT NULL THEN
      UTL_HTTP.set_transfer_timeout(v_http_request, p_timeout / 1000);
    END IF;
    UTL_HTTP.set_response_error_check(v_http_request, FALSE);

    -- Header Content-Type wird folgendermassen gesetzt:
    -- Content-Type: multipart/related; type="application/xop+xml"; boundary="----=_Part_941_406332184.1567595604772"
    UTL_HTTP.set_header(v_http_request, 'Content-Type', c_content_type_multipart || '; type="' || c_content_type_xop || '"; boundary="' || c_boundary || '"');
    UTL_HTTP.set_header(v_http_request, 'Content-Length', l_blob_length);
    -- Response im Charset der Datenbank anfordern
    UTL_HTTP.set_header(v_http_request, 'Accept-Charset', g_charset); -- R4.10
    UTL_HTTP.set_header(v_http_request, 'SOAPAction', p_action);
    -- write_raw kann nur 32 K pro Aufruf schreiben, deshalb mehrmaliger
    -- Aufruf um auch groessere Datenmengen uebergeben zu koennen.
    WHILE v_zaehler <= l_blob_length
    LOOP
      UTL_HTTP.write_raw(v_http_request, DBMS_LOB.SUBSTR(l_blob, 32767, v_zaehler));
      v_zaehler := v_zaehler + 32767;
    END LOOP;

    dbms_lob.freeTemporary(l_blob);

    v_http_response := UTL_HTTP.get_response(v_http_request);

    -- Response-Code in interner Variable speichern
    g_http_response_code := v_http_response.status_code;

    -- Pruefen auf ReturnCode
    IF v_http_response.status_code != UTL_HTTP.HTTP_OK AND v_http_response.status_code != 500 THEN
      UTL_HTTP.read_text(v_http_response, v_response_line);
      UTL_HTTP.end_response(v_http_response);
      RAISE_APPLICATION_ERROR(-20001, 'Fehler ' || v_http_response.status_code || ' ' || v_http_response.reason_phrase || ' beim Http Request');
    END IF;

    -- Content-Type der Response ermitteln und auf MTOM prüfen
    get_response_content_type (v_http_response, v_content_type, v_is_mtom);

    -- Initialisierung des CLOB.
    DBMS_LOB.createTemporary(v_response, TRUE, dbms_lob.call);

    IF v_is_mtom
    THEN
      decode_mtom_response (v_http_response, v_content_type, v_response);
      «AttachmentContextPackageName()».set_mtom_flag(TRUE);
    ELSE
      -- Das Ergebnis wird in einer Schleife ausgelesen
      -- Es werden immer 32K grosse Teile der Antwort ausgelesen.
      -- In der Exception wird, wenn die Antwort ausgelesen wurde, der Response geschlossen
      BEGIN
        LOOP
          UTL_HTTP.read_text(v_http_response, v_response_line);
          DBMS_LOB.writeappend(v_response, LENGTH(v_response_line), v_response_line);
        END LOOP;
      EXCEPTION
        WHEN UTL_HTTP.end_of_body THEN
          UTL_HTTP.end_response(v_http_response);
      END;
    END IF;
    
    IF p_url LIKE 'https://%'
    THEN
      utl_http.destroy_request_context(v_req_context); 
    END IF;

    return v_response;

  END call_soap_http_mtom;
«ENDIF-»

BEGIN
  -- Sessionweite Initialisierungen für UTL_HTTP
  
  -- Detailierte Exceptions aktivieren
  UTL_HTTP.set_detailed_excp_support(TRUE);
      
  -- Persistent Connections aktivieren
  utl_http.set_persistent_conn_support (enable => TRUE, max_conns => 10);

  -- Wallet mit Zertifikaten für HTTPS setzen
  -- UTL_HTTP.set_wallet('file:/u01/app/oracle/admin/wallet');
  «BasePackage_getPackageInitializer()»

END «BasePackageName()»;
/
«ENDFILE»

«ENDDEFINE»
