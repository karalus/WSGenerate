«IMPORT com::artofarc::wsimport»

«IMPORT javax::wsdl»

«EXTENSION oaw::extensions::db»
«EXTENSION oaw::extensions::wsdl»

«DEFINE Root(Definition definition) FOR Model»
«FOREACH definition.getSOAPBindings().portType.toSet() AS portType»
«IF generateServer(portType)»
«EXPAND Provider(definition, portType)»
«ENDIF»
«IF generateClient(portType)»
«EXPAND Consumer(definition, portType)»
«ENDIF»
«ENDFOREACH»
«ENDDEFINE»

«DEFINE Provider(Definition definition, PortType portType) FOR Model»
«FILE "plsql/" + getDBSchema() + "/" + WSDL2PackageName(portType, ArtifactKind::ProviderSkeleton) + ".PKB"-»
CREATE OR REPLACE PACKAGE BODY «getDBSchema()».«WSDL2PackageName(portType, ArtifactKind::ProviderSkeleton)» IS
  /**
  * <pre>
  *
  *  <br/>
  *  WebService:          «portType.QName.localPart» in «portType.QName.namespaceURI»
  *  documentBaseURI:     «definition.documentBaseURI»
  *  <br/>
  *
  *  <b>Beschreibung:</b>
  *
«definition.getDocumentation().formatDocumentation("  * ")-»
  *
  *  </pre>
  *  @headcom
  *
  *  Änderungs-Historie:   (neue Einträge immer oben anfügen)
  *  ========================================================
  *  Revision  Wann      Wer              Was
  *  --------  --------  ---------------  ----------------------------------------
  *  R1.0      heute     WSGenerate       Generierung des Packages
  */

  -- Package-Name
  c_package_name CONSTANT «BasePackageName()».oraclename_t := '«WSDL2PackageName(portType, ArtifactKind::ProviderSkeleton)»';

  ------------------------------------------------------------------------------
  -- öffentliche Typen und Variablen
  ------------------------------------------------------------------------------

  ------------------------------------------------------------------------------
  -- globale Cursors
  ------------------------------------------------------------------------------

  ------------------------------------------------------------------------------
  -- globale Exceptions
  ------------------------------------------------------------------------------

  ------------------------------------------------------------------------------
  -- spezifische Prozeduren/Funktionen
  ------------------------------------------------------------------------------

«FOREACH definition.getSOAPBindings(portType) AS binding-»
«FOREACH (List[BindingOperation]) binding.bindingOperations AS bindingOperation»
«EXPAND OperationContentP(portType, binding, bindingOperation)»
«ENDFOREACH»
«ENDFOREACH»

END «WSDL2PackageName(portType, ArtifactKind::ProviderSkeleton)»;
/
«ENDFILE»
«REM»========================================================================«ENDREM»
«LET definition.getSOAPBindings(portType).reject(e|e.isJmsTransport()) AS bindings»
«IF bindings.size > 0»
«FILE "plsql/" + getDBSchema() + "/" + WSDL2PackageName(portType, ArtifactKind::XMLAdapter) + ".PKB"-»
CREATE OR REPLACE PACKAGE BODY «getDBSchema()».«WSDL2PackageName(portType, ArtifactKind::XMLAdapter)» IS
  /**
  * <pre>
  *
  *  <br/>
  *  WebService:          «portType.QName.localPart» in «portType.QName.namespaceURI»
  *  documentBaseURI:     «definition.documentBaseURI»
  *  <br/>
  *
  *  <b>Beschreibung:</b>
  *
«definition.getDocumentation().formatDocumentation("  * ")-»
  *
  *
  *  </pre>
  *  @headcom
  *  <pre>
  *  !!! A C H T U N G  -- Modul ist generiert -- bitte nicht ändern !!!!
  *	 WSGenerate Version «getGeneratorVersion()» Build Time «getGeneratorBuildTime()»
  *
  */

  -- Package-Name
  c_package_name CONSTANT «BasePackageName()».oraclename_t := '«WSDL2PackageName(portType, ArtifactKind::XMLAdapter)»';

«FOREACH definition.getSOAPBindings(portType) AS binding-»
«FOREACH (List[BindingOperation]) binding.bindingOperations AS bindingOperation»
«EXPAND OperationContentX(portType, binding, bindingOperation)»
«ENDFOREACH»
«ENDFOREACH»

END «WSDL2PackageName(portType, ArtifactKind::XMLAdapter)»;
/
«ENDFILE»
«ENDIF»
«ENDLET»
«REM»========================================================================«ENDREM»
«ENDDEFINE»

«DEFINE Consumer(Definition definition, PortType portType) FOR Model»
«FILE "plsql/" + getDBSchema() + "/" + WSDL2PackageName(portType, ArtifactKind::ClientStub) + ".PKB"-»
CREATE OR REPLACE PACKAGE BODY «getDBSchema()».«WSDL2PackageName(portType, ArtifactKind::ClientStub)» IS
  /**
  * <pre>
  *
  *  <br/>
  *  WebService:          «portType.QName.localPart» in «portType.QName.namespaceURI»
  *  documentBaseURI:     «definition.documentBaseURI»
  *  <br/>
  *
  *  <b>Beschreibung:</b>
  *
«definition.getDocumentation().formatDocumentation("  * ")-»
  *
  *  </pre>
  *  @headcom
  *  <pre>
  *  !!! A C H T U N G  -- Modul ist generiert -- bitte nicht ändern !!!!
  *	 WSGenerate Version «getGeneratorVersion()» Build Time «getGeneratorBuildTime()»
  *
  */

  -- Package-Name
  c_package_name CONSTANT «BasePackageName()».oraclename_t := '«WSDL2PackageName(portType, ArtifactKind::ClientStub)»';
«FOREACH definition.getSOAPBindings(portType) AS binding-»
  c_SOAP_NS      CONSTANT VARCHAR2(99) := «IF binding.isSOAP12()»'http://www.w3.org/2003/05/soap-envelope'«ELSE»'http://schemas.xmlsoap.org/soap/envelope/'«ENDIF»;

  g_url          VARCHAR2(255) := '«bindingDefinition.getPortTypeProperty(portType, "addressLocation", definition.getPort(binding).getLocation())»';

«FOREACH (List[BindingOperation]) binding.bindingOperations AS bindingOperation»
«EXPAND OperationContentC(portType, binding, bindingOperation)»
«ENDFOREACH»
«ENDFOREACH»

END «WSDL2PackageName(portType, ArtifactKind::ClientStub)»;
/
«ENDFILE»
«ENDDEFINE»

«DEFINE OperationContentP(PortType portType, Binding binding, BindingOperation bindingOperation) FOR Model-»
«LET portType.getOperation(bindingOperation.name, null, null) AS operation-»
  /**
  * WSDL Operation: «operation.name»
  *
«operation.getDocumentation().formatDocumentation("  * ")-»
  *
  * @param   p_param_in             IN  eingehende Message des Service.
«IF rawMessageIn(portType)-»
  * @param   p_raw_in               IN  eingehende Message im Rohformat.
«ENDIF-»
  * @param   p_param_out            OUT ausgehende Message des Service.
  * @param   p_error_out            OUT ausgehende Fault Message des Service.
  *
  */
  PROCEDURE «operation.name» (
      p_param_in               IN         «getParameterOracleFQN(getInputElementQName(binding, operation.name))»
«IF rawMessageIn(portType)-»
    , p_raw_in                 IN         CLOB
«ENDIF-»
«IF !binding.isJmsTransport()-»
    , p_param_out              OUT NOCOPY «getParameterOracleFQN(getOutputElementQName(binding, operation.name))»
«IF getFaultElementQName(binding, operation.name) != null-»
    , p_error_out              OUT NOCOPY «getParameterOracleFQN(getFaultElementQName(binding, operation.name))»
«ENDIF-»
«ENDIF-»
  ) IS
    -- Komplexe Type-Variablen für Parameter der Geschäftslogik-Schicht (return, in, out und in/out) !!!! dies ist individuell anzupassen !!!! ---

    c_routine           CONSTANT «BasePackageName()».oraclename_T := '«operation.name»';

  BEGIN

«IF bindingDefinition.getPortTypeProperty(portType, "impl." + operation.name, null) != null-»
	«bindingDefinition.getPortTypeProperty(portType, "impl." + operation.name, null)»
«ELSE-»
    ---------------------------------------------------------------------------
    -- !!!! BEGIN Implementierung individueller Teil der Operation         !!!!
    ---------------------------------------------------------------------------

    ---------------------------------------------------------------------------
    -- Konvertieren / Transformieren der generierten RECORDs in Geschäftslogik-Datentypen
    ---------------------------------------------------------------------------

    ---------------------------------------------------------------------------
    -- Aufruf der Geschäftslogik-Logik
    ---------------------------------------------------------------------------

«IF bindingDefinition.getPortTypeProperty(portType, "delegate", null) != null-»
	«bindingDefinition.getPortTypeProperty(portType, "delegate", null)».«operation.name»(p_param_in«IF rawMessageIn(portType)», p_raw_in«ENDIF»«IF !binding.isJmsTransport()», p_param_out«IF getFaultElementQName(binding, operation.name) != null», p_error_out«ENDIF»«ENDIF»);
«ELSE-»
    RAISE_APPLICATION_ERROR(-20004, 'Not implemented, yet');
«ENDIF-»

    ---------------------------------------------------------------------------
    -- Konvertieren / Transformieren der Geschäftslogik-Datentypen in die generierten RECORDs
    ---------------------------------------------------------------------------

    ---------------------------------------------------------------------------
    -- Erfolgreich beenden - OUT-Message-Header oder Fehler Struktur entsprechend füllen.
    ---------------------------------------------------------------------------

    ------------------------------------------------------------------------------
    -- Exception - Aufruf ggf. mit Fehlerbehandlung beenden - Ggf. Fehler Struktur (p_error_out) entsprechend füllen.
    ------------------------------------------------------------------------------

--  EXCEPTION WHEN OTHERS THEN RAISE;

    ---------------------------------------------------------------------------
    -- !!!! ENDE individueller Teil der implementierten Operation          !!!!
    ---------------------------------------------------------------------------
«ENDIF-»

  END «operation.name»;
«ENDLET-»
«ENDDEFINE»

«DEFINE OperationContentX(PortType portType, Binding binding, BindingOperation bindingOperation) FOR Model-»
«LET portType.getOperation(bindingOperation.name, null, null) AS operation-»
  /**
  * XML Wrapper für «operation.name»
  */
  PROCEDURE «operation.name» (
      p_param_in               IN         CLOB
    , p_param_out              OUT NOCOPY CLOB
    , p_fault_out              OUT        NUMBER
  ) IS

    c_routine           CONSTANT «BasePackageName()».oraclename_t       := '«operation.name»';

    param_in               		 «getParameterOracleFQN(getInputElementQName(binding, operation.name))»;
    param_out                    «getParameterOracleFQN(getOutputElementQName(binding, operation.name))»;
«IF getFaultElementQName(binding, operation.name) != null-»
    error_out              		 «getParameterOracleFQN(getFaultElementQName(binding, operation.name))»;
«ENDIF-»

  BEGIN

    param_in := «getOracleFQN(getInputElementQName(binding, operation.name))»_4x(p_param_in);

    «WSDL2PackageName(portType, ArtifactKind::ProviderSkeleton)».«operation.name»(param_in«IF rawMessageIn(portType)», p_param_in«ENDIF», param_out«IF getFaultElementQName(binding, operation.name) != null», error_out«ENDIF»);

«IF getFaultElementQName(binding, operation.name) != null-»
    IF «getParameterPackagePrefix(getOutputElementQName(binding, operation.name))»isNotNull(param_out) THEN
«ENDIF-»
      p_param_out := «getOracleFQN(getOutputElementQName(binding, operation.name))»_2x(param_out);
      p_fault_out := 0;
«IF getFaultElementQName(binding, operation.name) != null-»
    ELSE
      p_param_out := «getOracleFQN(getFaultElementQName(binding, operation.name))»_2x(error_out);
      p_fault_out := 1;
    END IF;
«ENDIF-»

  END «operation.name»;
«ENDLET-»
«ENDDEFINE»

«DEFINE OperationContentC(PortType portType, Binding binding, BindingOperation bindingOperation) FOR Model-»
«LET portType.getOperation(bindingOperation.name, null, null) AS operation-»
  /**
  * WSDL Operation: «operation.name»
  *
«operation.getDocumentation().formatDocumentation("  * ")-»
  *
  * @param   p_param_in             IN  eingehende Message des Service.
«IF !binding.isJmsTransport()-»
  * @param   p_param_out            OUT ausgehende Message des Service.
«IF getFaultElementQName(binding, operation.name) != null-»
  * @param   p_error_out            OUT ausgehende Fault Message des Service.
«ENDIF-»
«ENDIF-»
  *
  */
  PROCEDURE «operation.name» (
      p_param_in               IN OUT NOCOPY «getParameterOracleFQN(getInputElementQName(binding, operation.name))»
«IF !binding.isJmsTransport()-»
    , p_param_out              OUT    NOCOPY «getParameterOracleFQN(getOutputElementQName(binding, operation.name))»
«IF getFaultElementQName(binding, operation.name) != null-»
    , p_error_out              OUT    NOCOPY «getParameterOracleFQN(getFaultElementQName(binding, operation.name))»
«ENDIF-»
«ENDIF-»
  ) IS

    c_routine           CONSTANT «BasePackageName()».oraclename_T := '«operation.name»';

    param_in				     CLOB;
    param_out     			     CLOB;

    outdomdoc 					 DBMS_XMLDOM.DOMDocument;
    outdocnode   		         DBMS_XMLDOM.DOMNode;
    outnode   					 DBMS_XMLDOM.DOMNode;
    outelmt 			         DBMS_XMLDOM.DOMElement;

    myparser 					 DBMS_XMLPARSER.parser;

    indomdoc 					 DBMS_XMLDOM.DOMDocument;
    inelmt 			             DBMS_XMLDOM.DOMElement;
    innode 				         DBMS_XMLDOM.DOMNode;
    text                         DBMS_XMLDOM.DOMNode;

    timeout                      INTEGER;
	fault_mapped                 BOOLEAN := FALSE;
    fault_string                 VARCHAR2(4000);
    v_url                        VARCHAR2(255);

  BEGIN

    outdomdoc := DBMS_XMLDOM.newDOMDocument;
    outdocnode := DBMS_XMLDOM.makeNode(outdomdoc);

    outelmt := DBMS_XMLDOM.createElement(outdomdoc, 'soapenv:Envelope', c_SOAP_NS);
    DBMS_XMLDOM.setAttribute(outelmt, 'xmlns:soapenv', c_SOAP_NS);
    outnode := DBMS_XMLDOM.appendChild(outdocnode, DBMS_XMLDOM.makeNode(outelmt));

    outelmt := DBMS_XMLDOM.createElement(outdomdoc, 'soapenv:Body', c_SOAP_NS);
    outnode := DBMS_XMLDOM.appendChild(outnode, DBMS_XMLDOM.makeNode(outelmt));

    outelmt := DBMS_XMLDOM.createElement(outdomdoc, '«getInputElementQName(binding, operation.name).localPart»', '«getInputElementQName(binding, operation.name).namespaceURI»');
    DBMS_XMLDOM.setAttribute(outelmt, 'xmlns', '«getInputElementQName(binding, operation.name).namespaceURI»');
    outnode := DBMS_XMLDOM.appendChild(outnode, DBMS_XMLDOM.makeNode(outelmt));
    «getParameterOracleFQN(getInputElementQName(binding, operation.name))»2x(p_param_in, outdomdoc, outnode, '«getInputElementQName(binding, operation.name).namespaceURI»');

    DBMS_LOB.createTemporary(param_in, TRUE, dbms_lob.call);
    DBMS_XMLDOM.writeToClob(outdocnode, param_in);
    DBMS_XMLDOM.freeDocument(outdomdoc);

    v_url := «BasePackageName()».getUrlForService(c_PortType_URI, '«binding.portType.QName.localPart»', g_url);
    param_out := «BasePackageName()».call_soap_http(v_url, '"«bindingOperation.getSoapActionURI()»"', timeout, param_in, «IF binding.isSOAP12()»TRUE«ELSE»FALSE«ENDIF»);
    DBMS_LOB.freeTemporary(param_in);

    myParser := DBMS_XMLPARSER.newParser;
    DBMS_XMLPARSER.parseClob(myParser, param_out);
    DBMS_LOB.freeTemporary(param_out);
    indomdoc := DBMS_XMLPARSER.getDocument(myParser);
    DBMS_XMLPARSER.freeParser(myParser);
    inelmt := DBMS_XMLDOM.getDocumentElement(indomdoc);
    innode := DBMS_XMLDOM.makeNode(inelmt);
    -- Last Child ist immer Body, auch wenn ein Header da ist
    innode := DBMS_XMLDOM.getLastChild(innode);
    innode := DBMS_XMLDOM.getFirstChild(innode);
    inelmt := DBMS_XMLDOM.makeElement(innode);
    IF DBMS_XMLDOM.getNamespace(inelmt) = c_SOAP_NS AND DBMS_XMLDOM.getLocalName(inelmt) = 'Fault' THEN
      innode := DBMS_XMLDOM.getFirstChild(innode); -- faultcode
      innode := DBMS_XMLDOM.getNextSibling(innode); -- faultstring
      text := DBMS_XMLDOM.getFirstChild(innode);
      fault_string := DBMS_XMLDOM.getNodeValue(text);
      innode := DBMS_XMLDOM.getNextSibling(innode);
      IF NOT DBMS_XMLDOM.isNull(innode) THEN
        inelmt := DBMS_XMLDOM.makeElement(innode);
        IF DBMS_XMLDOM.getLocalName(inelmt) = 'faultactor' THEN
          innode := DBMS_XMLDOM.getNextSibling(innode); -- detail
          IF NOT DBMS_XMLDOM.isNull(innode) THEN
            inelmt := DBMS_XMLDOM.makeElement(innode);
          END IF;
        END IF;
        IF DBMS_XMLDOM.getLocalName(inelmt) = 'detail' THEN
          innode := DBMS_XMLDOM.getFirstChild(innode);
«IF getFaultElementQName(binding, operation.name) != null-»
          inelmt := DBMS_XMLDOM.makeElement(innode);
          IF DBMS_XMLDOM.getNamespace(inelmt) = '«getFaultElementQName(binding, operation.name).namespaceURI»' AND DBMS_XMLDOM.getLocalName(inelmt) = '«getFaultElementQName(binding, operation.name).localPart»' THEN
            p_error_out := «getParameterOracleFQN(getFaultElementQName(binding, operation.name))»4x(innode);
            fault_mapped := TRUE;
          ELSE
            text := DBMS_XMLDOM.getFirstChild(innode);
            fault_string := fault_string || DBMS_XMLDOM.getNodeValue(text);
          END IF;
«ELSE-»
          text := DBMS_XMLDOM.getFirstChild(innode);
          fault_string := fault_string || DBMS_XMLDOM.getNodeValue(text);
«ENDIF-»
        END IF;
      END IF;
      IF NOT fault_mapped THEN
        DBMS_XMLDOM.freeDocument(indomdoc);
        RAISE_APPLICATION_ERROR(-20001, 'Fault: ' || fault_string);
      END IF;
    ELSE
      p_param_out := «getParameterOracleFQN(getOutputElementQName(binding, operation.name))»4x(innode);
    END IF;
    DBMS_XMLDOM.freeDocument(indomdoc);

  END «operation.name»;
«ENDLET-»
«ENDDEFINE»
